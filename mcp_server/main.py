# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T04:54:55+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import (
    BaseSecurity,
    HTTPBearer,
    UnsuportedSecurityStub,
)
from fastapi import Header

from models import (
    Account,
    AccountIds,
    AdminAccount,
    AdminReport,
    ApiV1AccountsIdFeaturedTagsGetResponse,
    ApiV1AccountsIdFollowersGetResponse,
    ApiV1AccountsIdFollowingGetResponse,
    ApiV1AccountsIdIdentityProofsGetResponse,
    ApiV1AccountsIdListsGetResponse,
    ApiV1AccountsIdStatusesGetResponse,
    ApiV1AccountsRelationshipsGetResponse,
    ApiV1AccountsSearchGetResponse,
    ApiV1AdminAccountsGetResponse,
    ApiV1AdminAccountsIdActionPostRequest,
    ApiV1AdminReportsGetResponse,
    ApiV1AnnouncementsGetResponse,
    ApiV1AnnouncementsIdDismissPostResponse,
    ApiV1AnnouncementsIdReactionsNameDeleteResponse,
    ApiV1AnnouncementsIdReactionsNamePutResponse,
    ApiV1AppsPostResponse,
    ApiV1BlocksGetResponse,
    ApiV1BookmarksGetResponse,
    ApiV1ConversationsGetResponse,
    ApiV1ConversationsIdDeleteResponse,
    ApiV1CustomEmojisGetResponse,
    ApiV1DirectoryGetResponse,
    ApiV1DomainBlocksDeleteResponse,
    ApiV1DomainBlocksGetResponse,
    ApiV1DomainBlocksPostResponse,
    ApiV1EndorsementsGetResponse,
    ApiV1FavouritesGetResponse,
    ApiV1FeaturedTagsGetResponse,
    ApiV1FeaturedTagsIdDeleteResponse,
    ApiV1FeaturedTagsPostRequest,
    ApiV1FeaturedTagsSuggestionsGetResponse,
    ApiV1FiltersGetResponse,
    ApiV1FollowRequestsGetResponse,
    ApiV1InstanceActivityGetResponse,
    ApiV1InstancePeersGetResponse,
    ApiV1ListsDeleteResponse,
    ApiV1ListsGetResponse,
    ApiV1ListsIdAccountsDeleteResponse,
    ApiV1ListsIdAccountsGetResponse,
    ApiV1ListsIdAccountsPostRequest,
    ApiV1ListsIdAccountsPostResponse,
    ApiV1ListsPostRequest,
    ApiV1ListsPutRequest,
    ApiV1MarkersGetResponse,
    ApiV1MarkersPostRequest,
    ApiV1MarkersPostResponse,
    ApiV1MutesGetResponse,
    ApiV1NotificationsClearPostResponse,
    ApiV1NotificationsGetResponse,
    ApiV1PollsIdPostRequest,
    ApiV1PushSubscriptionDeleteResponse,
    ApiV1PushSubscriptionPostRequest,
    ApiV1PushSubscriptionPutRequest,
    ApiV1ReportsPostRequest,
    ApiV1ScheduledStatusesGetResponse,
    ApiV1ScheduledStatusesIdDeleteResponse,
    ApiV1ScheduledStatusesIdPutRequest,
    ApiV1StatusesIdReblogPostRequest,
    ApiV1StatusesPostRequest,
    ApiV1StatusesPostResponse,
    ApiV1SuggestionsIdDeleteResponse,
    ApiV1TimelinesHomeGetResponse,
    ApiV1TimelinesListListIdGetResponse,
    ApiV1TimelinesPublicGetResponse,
    ApiV1TimelinesTagHashtagGetResponse,
    ApiV1TrendsGetResponse,
    ApiV2SearchGetResponse,
    Application,
    Attachment,
    Card,
    Context,
    Conversation,
    Error,
    ExcludeTypes,
    FeaturedTag,
    Filter,
    Id,
    IdentityProof,
    Instance,
    ListModel,
    Notification,
    OauthTokenPostResponse,
    Order,
    Poll,
    Preferences,
    PushSubscription,
    Relationship,
    Report,
    ScheduledStatus,
    Status,
    Timeline,
    Type4,
)

app = MCPProxy(
    contact={'email': 'sardo@hey.com', 'name': 'Sardorbek Pulatov'},
    title='Mastodon API Specification (https://github.com/mastodon/mastodon)',
    version='1.0',
    servers=[{'url': 'http://mastodon.local'}, {'url': 'https://mastodon.social'}],
)


@app.get(
    '/api/oembed', description=""" OEmbed as JSON """, tags=['content_embed_retrieval']
)
def get_api_oembed(
    url: Optional[str] = None,
    maxwidth: Optional[int] = 400,
    maxheight: Optional[int] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/proofs',
    description=""" View identity proof """,
    tags=['user_account_operations', 'user_relationship_operations'],
)
def get_api_proofs(provider: Optional[str] = None, username: Optional[str] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/accounts',
    description=""" Creates a user and account records. Returns an account access token for the app that initiated the request. The app should save this token for later, and should wait for the user to confirm their account by clicking a link in their email inbox. """,
    tags=['None'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_accounts():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/accounts/relationships',
    description=""" Sets a private note on a user. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_accounts_relationships(id: Id):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/accounts/search',
    description=""" Search for matching accounts by username or display name. """,
    tags=['search_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_accounts_search(
    q: str,
    limit: Optional[int] = 40,
    resolve: Optional[str] = None,
    following: Optional[bool] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/api/v1/accounts/update_credentials',
    description=""" Update the user's display and preferences. """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'report_management_operations',
        'administration_account_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def patch_api_v1_accounts_update_credentials():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/accounts/verify_credentials',
    description=""" Test to make sure that the user token works. """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
        'report_management_operations',
        'notification_handling',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_accounts_verify_credentials():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/accounts/{id}',
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_accounts__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/accounts/{id}/block',
    description=""" Block the given account. Clients should filter statuses from this account if received (e.g. due to a boost in the Home timeline). """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_accounts__id_block(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/accounts/{id}/featured_tags',
    description=""" Tags featured by this account. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_accounts__id_featured_tags(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/accounts/{id}/follow',
    description=""" Follow the given account. Can also be used to update whether to show reblogs or enable notifications. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_accounts__id_follow(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/accounts/{id}/followers',
    description=""" Accounts which follow the given account, if network is not hidden by the account owner. """,
    tags=['user_directory_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_accounts__id_followers(
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    limit: Optional[int] = 40,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/accounts/{id}/following',
    description=""" Accounts which the given account is following, if network is not hidden by the account owner. """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_directory_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_accounts__id_following(
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    limit: Optional[int] = 40,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/accounts/{id}/identity_proofs',
    description=""" Array of IdentityProof """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_accounts__id_identity_proofs(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/accounts/{id}/lists',
    description=""" User lists that you have added this account to. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_accounts__id_lists(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/accounts/{id}/mute',
    description=""" Mute the given account. Clients should filter statuses and notifications from this account, if received (e.g. due to a boost in the Home timeline). """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_accounts__id_mute(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/accounts/{id}/note',
    description=""" Sets a private note on a user. """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_accounts__id_note(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/accounts/{id}/pin',
    description=""" Add the given account to the user's featured profiles. (Featured profiles are currently shown on the user's own public profile.) """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_accounts__id_pin(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/accounts/{id}/statuses',
    description=""" Statuses posted to the given account. """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_accounts__id_statuses(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/accounts/{id}/unblock',
    description=""" Block the given account. Clients should filter statuses from this account if received (e.g. due to a boost in the Home timeline). """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_accounts__id_unblock(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/accounts/{id}/unfollow',
    description=""" Unfollow the given account. """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_accounts__id_unfollow(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/accounts/{id}/unmute',
    description=""" Unmute the given account. """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_accounts__id_unmute(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/accounts/{id}/unpin',
    description=""" Remove the given account from the user's featured profiles. """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_accounts__id_unpin(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/admin/accounts',
    description=""" View accounts matching certain criteria for filtering, up to 100 at a time. Pagination may be done with the HTTP Link header in the response. """,
    tags=['user_account_operations', 'user_directory_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_admin_accounts(
    local: Optional[bool] = None,
    remote: Optional[bool] = None,
    by_domain: Optional[str] = None,
    active: Optional[bool] = None,
    pending: Optional[bool] = None,
    disabled: Optional[bool] = None,
    silenced: Optional[bool] = None,
    suspended: Optional[bool] = None,
    staff: Optional[bool] = None,
    username: Optional[str] = None,
    display_name: Optional[str] = None,
    email: Optional[str] = None,
    ip: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/admin/accounts/{id}',
    description=""" View admin-level information about the given account. """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_admin_accounts__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/admin/accounts/{id}/action',
    description=""" Perform an action against an account and log this action in the moderation history. """,
    tags=['admin_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_admin_accounts__id_action(
    id: str, body: ApiV1AdminAccountsIdActionPostRequest = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/admin/accounts/{id}/approve',
    description=""" Approve the given local account if it is currently pending approval. """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_admin_accounts__id_approve(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/admin/accounts/{id}/enable',
    description=""" Re-enable a local account whose login is currently disabled. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_admin_accounts__id_enable(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/admin/accounts/{id}/reject',
    description=""" Reject the given local account if it is currently pending approval. """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_admin_accounts__id_reject(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/admin/accounts/{id}/unsilence',
    description=""" Unsilence a currently silenced account. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_admin_accounts__id_unsilence(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/admin/accounts/{id}/unsuspend',
    description=""" Unsuspend a currently suspended account. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_admin_accounts__id_unsuspend(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/admin/reports',
    description=""" View all reports. Pagination may be done with HTTP Link header in the response. """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_admin_reports(
    resolved: Optional[bool] = None,
    account_id: Optional[str] = None,
    target_account_id: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/admin/reports/{id}',
    description=""" View information about the report with the given ID. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_admin_reports__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/admin/reports/{id}/assign_to_self',
    description=""" Claim the handling of this report to yourself. """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_admin_reports__id_assign_to_self(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/admin/reports/{id}/reopen',
    description=""" Mark a report as resolved with no further action taken. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_admin_reports__id_reopen(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/admin/reports/{id}/resolve',
    description=""" Mark a report as resolved with no further action taken. """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
        'user_directory_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_admin_reports__id_resolve(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/admin/reports/{id}/unassign',
    description=""" Unassign a report so that someone else can claim it. """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_admin_reports__id_unassign(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/announcements',
    description=""" See all currently active announcements set by admins. """,
    tags=['announcement_handling', 'notification_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_announcements(with_dismissed: Optional[bool] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/announcements/{id}/dismiss',
    description=""" Allows a user to mark the announcement as read. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_announcements__id_dismiss(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/v1/announcements/{id}/reactions/{name}',
    description=""" Undo a react emoji to an announcement. """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_api_v1_announcements__id_reactions__name(id: str, name: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/api/v1/announcements/{id}/reactions/{name}',
    description=""" Allows a user to mark the announcement as read. """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def put_api_v1_announcements__id_reactions__name(id: str, name: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/apps',
    description=""" Create a new application to obtain OAuth2 credentials. """,
    tags=[
        'content_embed_retrieval',
        'user_account_operations',
        'user_relationship_operations',
        'admin_account_operations',
        'user_verification_process',
        'report_management_operations',
        'announcement_handling',
        'application_management_operations',
        'blocklist_operations',
        'conversation_handling',
        'bookmark_handling',
        'custom_emoji_handling',
        'user_directory_management',
        'endorsement_handling',
        'favourite_handling',
        'tag_management_operations',
        'filter_operations',
        'follow_request_management',
        'instance_information_retrieval',
        'list_handling',
        'marker_handling',
        'media_handling_operations',
        'mute_operations',
        'notification_handling',
        'poll_handling',
        'push_subscription_handling',
        'status_handling_operations',
        'scheduled_status_handling',
        'user_suggestion_handling',
        'timeline_access_management',
        'user_preference_retrieval',
        'public_timeline_retrieval',
        'trending_topic_retrieval',
        'search_operations',
        'oauth_management',
    ],
)
def post_api_v1_apps():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/apps/verify_credentials',
    description=""" Confirm that the app's OAuth2 credentials work. """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_apps_verify_credentials():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/blocks',
    description=""" Get blocked users. """,
    tags=['user_directory_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_blocks(
    limit: Optional[int] = None,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/bookmarks',
    description=""" Statuses the user has bookmarked. """,
    tags=['user_directory_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_bookmarks(
    limit: Optional[int] = None,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/conversations',
    description=""" Show conversation. """,
    tags=['user_directory_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_conversations(
    limit: Optional[int] = 20,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/v1/conversations/{id}',
    description=""" Remove converstation """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_api_v1_conversations__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/conversations/{id}/read',
    description=""" Remove converstation """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_conversations__id_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/custom_emojis',
    description=""" Returns custom emojis that are available on the server. """,
    tags=['search_operations'],
)
def get_api_v1_custom_emojis():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/directory',
    description=""" List accounts visible in the directory. """,
    tags=['user_directory_management'],
)
def get_api_v1_directory(
    limit: Optional[int] = 40,
    offset: Optional[int] = 0,
    order: Optional[Order] = 'active',
    local: Optional[bool] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/v1/domain_blocks',
    description=""" Remove a domain block, if it exists in the user's array of blocked domains. """,
    tags=['instance_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_api_v1_domain_blocks(domain: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/domain_blocks',
    description=""" View domains the user has blocked. """,
    tags=['user_directory_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_domain_blocks(
    limit: Optional[int] = None,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/domain_blocks',
    description=""" "Block a domain to:
- hide all public posts from it
- hide all notifications from it
- remove all followers from it
- prevent following new users from it (but does not remove existing follows)"
 """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
        'report_management_operations',
        'notification_handling',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_domain_blocks():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/endorsements',
    description=""" Accounts that the user is currently featuring on their profile. """,
    tags=['user_directory_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_endorsements(
    limit: Optional[int] = 40,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/favourites',
    description=""" Statuses the user has favourited. """,
    tags=['user_directory_management', 'search_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_favourites(
    limit: Optional[str] = None,
    max_id: Optional[str] = None,
    min_id: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/featured_tags',
    description=""" View your featured tags. """,
    tags=['None'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_featured_tags():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/featured_tags',
    description=""" Create a feature a tag. """,
    tags=['tag_management_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_featured_tags(body: ApiV1FeaturedTagsPostRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/featured_tags/suggestions',
    description=""" Shows your 10 most-used tags, with usage history for the past week. """,
    tags=['oauth_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_featured_tags_suggestions():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/v1/featured_tags/{id}',
    description=""" Unfeature a tag """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_api_v1_featured_tags__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/filters',
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
        'report_management_operations',
        'announcement_handling',
        'application_management_operations',
        'blocklist_operations',
        'conversation_handling',
        'bookmark_handling',
        'custom_emoji_handling',
        'user_directory_management',
        'endorsement_handling',
        'favourite_handling',
        'tag_management_operations',
        'filter_operations',
        'follow_request_management',
        'instance_information_retrieval',
        'list_handling',
        'marker_handling',
        'media_handling_operations',
        'mute_operations',
        'notification_handling',
        'poll_handling',
        'push_subscription_handling',
        'status_handling_operations',
        'scheduled_status_handling',
        'user_suggestion_handling',
        'timeline_access_management',
        'user_preference_retrieval',
        'public_timeline_retrieval',
        'trending_topic_retrieval',
        'search_operations',
        'oauth_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_filters():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/filters',
    tags=['search_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_filters():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/v1/filters/{id}',
    description=""" Delete a filter. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_api_v1_filters__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/filters/{id}',
    description=""" Get one filter. """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_filters__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/api/v1/filters/{id}',
    description=""" Update a filter. """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def put_api_v1_filters__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/follow_requests',
    description=""" Pending Follows """,
    tags=['user_preference_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_follow_requests(limit: Optional[int] = 40):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/follow_requests/{id}/authorize',
    description=""" Accept Follow """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_follow_requests__id_authorize(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/follow_requests/{id}/reject',
    description=""" Accept Follow """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_follow_requests__id_reject(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/instance',
    description=""" Information about the server. """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
        'report_management_operations',
        'announcement_handling',
        'application_management_operations',
        'blocklist_operations',
        'conversation_handling',
        'bookmark_handling',
        'custom_emoji_handling',
        'user_directory_management',
        'endorsement_handling',
        'favourite_handling',
        'tag_management_operations',
        'filter_operations',
        'follow_request_management',
        'instance_information_retrieval',
        'list_handling',
        'marker_handling',
        'media_handling_operations',
        'mute_operations',
        'notification_handling',
        'poll_handling',
        'push_subscription_handling',
        'status_handling_operations',
        'scheduled_status_handling',
        'user_suggestion_handling',
        'timeline_access_management',
        'user_preference_retrieval',
        'public_timeline_retrieval',
        'trending_topic_retrieval',
        'search_operations',
        'oauth_management',
    ],
)
def get_api_v1_instance():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/instance/activity',
    description=""" Instance activity over the last 3 months, binned weekly. """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
        'search_operations',
    ],
)
def get_api_v1_instance_activity():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/instance/peers',
    description=""" Information about the server. """,
    tags=['user_account_operations'],
)
def get_api_v1_instance_peers():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/v1/lists',
    description=""" Delete a list """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_api_v1_lists():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/lists',
    description=""" Fetch all lists that the user owns. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_lists():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/lists',
    description=""" Create a new list. """,
    tags=['list_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_lists(body: ApiV1ListsPostRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/api/v1/lists',
    description=""" Change the title of a list, or which replies to show. """,
    tags=['list_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def put_api_v1_lists(body: ApiV1ListsPutRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/lists/{id}',
    description=""" Remove converstation """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_lists__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/v1/lists/{id}/accounts',
    description=""" Remove accounts from the given list. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_api_v1_lists__id_accounts(account_ids: AccountIds, id: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/lists/{id}/accounts',
    description=""" View accounts in List """,
    tags=['user_directory_management', 'timeline_access_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_lists__id_accounts(
    limit: Optional[int] = 40,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/lists/{id}/accounts',
    description=""" Add accounts to the given list. Note that the user must be following these accounts. """,
    tags=['user_account_operations', 'list_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_lists__id_accounts(
    id: str, body: ApiV1ListsIdAccountsPostRequest = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/markers',
    description=""" Get saved timeline position """,
    tags=['timeline_access_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_markers(timeline: Timeline):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/markers',
    description=""" Get saved timeline position """,
    tags=['marker_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_markers(body: ApiV1MarkersPostRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/media',
    description=""" Creates an attachment to be used with a new status. """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_media():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/media/{id}',
    description=""" Get an attachement. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_media__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/media/{id}',
    description=""" Update an Attachment, before it is attached to a status and posted. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_media__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/mutes',
    description=""" Accounts the user has muted. """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'timeline_access_management',
        'search_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_mutes(
    limit: Optional[str] = None,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/notifications',
    description=""" Notifications concerning the user. This API returns Link headers containing links to the next/previous page. However, the links can also be constructed dynamically using query params and id values. """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_directory_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_notifications(
    limit: Optional[int] = 20,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
    exclude_types: Optional[ExcludeTypes] = None,
    account_id: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/notifications/clear',
    description=""" Clear all notifications from the server. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_notifications_clear():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/notifications/{id}',
    description=""" View information about a notification with a given ID. """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_notifications__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/notifications/{id}/dismiss',
    description=""" Clear a single notification from the server. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_notifications__id_dismiss(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/polls/{id}',
    description=""" View a poll. """,
    tags=['user_account_operations'],
)
def get_api_v1_polls__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/polls/{id}',
    description=""" Vote on a poll. """,
    tags=['poll_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_polls__id(id: str, body: ApiV1PollsIdPostRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/preferences',
    description=""" Shows your 10 most-used tags, with usage history for the past week. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_preferences():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/v1/push/subscription',
    description=""" Updates the current push subscription. Only the data part can be updated. To change fundamentals, a new subscription must be created instead. """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_api_v1_push_subscription():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/push/subscription',
    description=""" View the PushSubscription currently associated with this access token. """,
    tags=['search_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_push_subscription():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/push/subscription',
    description=""" Add a Web Push API subscription to receive notifications. Each access token can have one push subscription. If you create a new subscription, the old subscription is deleted. """,
    tags=['push_subscription_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_push_subscription(body: ApiV1PushSubscriptionPostRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/api/v1/push/subscription',
    description=""" Updates the current push subscription. Only the data part can be updated. To change fundamentals, a new subscription must be created instead. """,
    tags=['push_subscription_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def put_api_v1_push_subscription(body: ApiV1PushSubscriptionPutRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/reports',
    description=""" File a report. """,
    tags=['report_management_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_reports(body: ApiV1ReportsPostRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/scheduled_statuses',
    description=""" View scheduled statuses """,
    tags=['user_directory_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_scheduled_statuses(
    limit: Optional[int] = 20,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/v1/scheduled_statuses/{id}',
    description=""" Cancel a scheduled status """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_api_v1_scheduled_statuses__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/scheduled_statuses/{id}',
    description=""" View a single scheduled status """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_scheduled_statuses__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/api/v1/scheduled_statuses/{id}',
    description=""" View a single scheduled status """,
    tags=['scheduled_status_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def put_api_v1_scheduled_statuses__id(
    id: str, body: ApiV1ScheduledStatusesIdPutRequest = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/statuses',
    tags=['status_handling_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_statuses(
    idempotency__key: Optional[str] = Header(None, alias='Idempotency-Key'),
    body: ApiV1StatusesPostRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/v1/statuses/{id}',
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_api_v1_statuses__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/statuses/{id}',
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_statuses__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/statuses/{id}/bookmark',
    description=""" Privately bookmark a status. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_statuses__id_bookmark(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/statuses/{id}/context',
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_statuses__id_context(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/statuses/{id}/favourite',
    description=""" Add a status to your favourites list. """,
    tags=['user_account_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_statuses__id_favourite(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/statuses/{id}/favourited_by',
    description=""" View who favourited a given status. """,
    tags=['user_account_operations'],
)
def get_api_v1_statuses__id_favourited_by(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/statuses/{id}/mute',
    description=""" Do not receive notifications for the thread that this status is part of. Must be a thread in which you are a participant. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_statuses__id_mute(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/statuses/{id}/pin',
    description=""" Feature one of your own public statuses at the top of your profile. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_statuses__id_pin(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/statuses/{id}/reblog',
    description=""" Reshare a status. """,
    tags=['status_handling_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_statuses__id_reblog(
    id: str, body: ApiV1StatusesIdReblogPostRequest = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/statuses/{id}/reblogged_by',
    description=""" View who boosted a given status. """,
    tags=['user_account_operations', 'user_relationship_operations'],
)
def get_api_v1_statuses__id_reblogged_by(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/statuses/{id}/unbookmark',
    description=""" Remove a status from your private bookmarks. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_statuses__id_unbookmark(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/statuses/{id}/unfavourite',
    description=""" Remove a status from your favourites list. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_statuses__id_unfavourite(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/statuses/{id}/unmute',
    description=""" Status's conversation unmuted, or was already unmuted """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_statuses__id_unmute(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/statuses/{id}/unpin',
    description=""" Unfeature a status from the top of your profile. """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_statuses__id_unpin(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/api/v1/statuses/{id}/unreblog',
    description=""" Undo a reshare of a status. """,
    tags=[
        'user_account_operations',
        'user_relationship_operations',
        'user_verification_process',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_api_v1_statuses__id_unreblog(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/suggestions',
    description=""" Accounts the user has had past positive interactions with, but is not yet following. """,
    tags=['user_suggestion_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_suggestions(limit: Optional[int] = 40):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/api/v1/suggestions/{id}',
    description=""" Delete user suggestion """,
    tags=['user_account_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_api_v1_suggestions__id(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/timelines/home',
    description=""" View statuses from followed users. """,
    tags=[
        'user_directory_management',
        'status_handling_operations',
        'search_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_timelines_home(
    local: Optional[bool] = False,
    limit: Optional[int] = 20,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/timelines/list/{list_id}',
    description=""" View statuses in the given list timeline. """,
    tags=['list_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v1_timelines_list__list_id(
    limit: Optional[int] = 20,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
    list_id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/timelines/public',
    description=""" Public timeline """,
    tags=['media_handling_operations', 'user_account_operations'],
)
def get_api_v1_timelines_public(
    local: Optional[bool] = False,
    remote: Optional[bool] = False,
    only_media: Optional[bool] = False,
    limit: Optional[int] = 20,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/timelines/tag/{hashtag}',
    description=""" View public statuses containing the given hashtag. """,
    tags=['public_timeline_retrieval', 'hashtag_search_operations'],
)
def get_api_v1_timelines_tag__hashtag(
    local: Optional[bool] = False,
    remote: Optional[bool] = False,
    only_media: Optional[bool] = False,
    limit: Optional[int] = 20,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
    hashtag: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v1/trends',
    description=""" Tags that are being used more frequently within the past week. """,
    tags=['user_directory_management'],
)
def get_api_v1_trends(limit: Optional[int] = 10):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/api/v2/search',
    description=""" Search results """,
    tags=['search_operations', 'user_relationship_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_api_v2_search(
    q: str,
    limit: Optional[int] = 20,
    resolve: Optional[str] = None,
    following: Optional[bool] = None,
    account_id: Optional[str] = None,
    max_id: Optional[str] = None,
    min_id: Optional[str] = None,
    type: Optional[Type4] = None,
    exclude_unreviewed: Optional[bool] = None,
    offset: Optional[int] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/oauth/authorize',
    description=""" Displays an authorization form to the user. If approved, it will create and return an authorization code, then redirect to the desired redirect_uri, or show the authorization code if urn:ietf:wg:oauth:2.0:oob was requested. The authorization code can be used while requesting a token to obtain access to user-level methods. """,
    tags=['oauth_management', 'user_account_operations'],
)
def get_oauth_authorize(
    response_type: str,
    client_id: str = ...,
    redirect_uri: str = ...,
    scope: Optional[str] = None,
    force_login: Optional[bool] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/oauth/revoke',
    description=""" Revoke an access token to make it no longer valid for use. """,
)
def post_oauth_revoke():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/oauth/token',
    description=""" Returns an access token, to be used during API calls that are not public. """,
    tags=['user_account_operations'],
)
def post_oauth_token():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
