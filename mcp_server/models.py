# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T04:54:55+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Field, RootModel, SecretStr


class Activity(BaseModel):
    logins: Optional[str] = Field(
        None,
        description='User logins since the week began, String (cast from an integer).',
    )
    registrations: Optional[str] = Field(
        None,
        description='User registrations since the week began, String (cast from an integer).',
    )
    statuses: Optional[str] = Field(
        None,
        description='Statuses created since the week began, String (cast from an integer).',
    )
    week: Optional[str] = Field(
        None, description='Midnight at the first day of the week.  (UNIX Timestamp).'
    )


class Announcement(BaseModel):
    all_day: bool = Field(
        ..., description='Whether the announcement has a start/end time.'
    )
    created_at: str = Field(..., description='When the announcement was created.')
    ends_at: Optional[str] = Field(
        None, description='When the future announcement will end. ISO 8601 Datetime.'
    )
    id: str = Field(
        ...,
        description='The announcement id. Cast from an integer, but not guaranteed to be a number.',
    )
    published: bool = Field(
        ..., description='Whether the announcement is currently active.'
    )
    read: bool = Field(
        ..., description='Whether the announcement has been read by the user.'
    )
    scheduled_at: Optional[str] = Field(
        None,
        description='When the future announcement was scheduled. ISO 8601 Datetime.',
    )
    starts_at: Optional[str] = Field(
        None, description='When the future announcement will start. ISO 8601 Datetime.'
    )
    text: str = Field(..., description='The content of the announcement.')
    updated_at: str = Field(
        ..., description='When the announcement was last updated. ISO 8601 Datetime.'
    )


class AnnouncementReaction(BaseModel):
    count: Optional[int] = Field(
        None, description='The total number of users who have added this reaction.'
    )
    me: Optional[bool] = Field(
        None,
        description='Whether the authorized user has added this reaction to the announcement.',
    )
    name: Optional[str] = Field(
        None,
        description="The emoji used for the reaction. Either a unicode emoji, or a custom emoji's shortcode.",
    )
    static_url: Optional[str] = Field(
        None, description='A link to a non-animated version of the custom emoji (URL).'
    )
    url: Optional[str] = Field(None, description='A link to the custom emoji (URL).')


class Application(BaseModel):
    client_id: Optional[str] = Field(
        None, description='Client ID key, to be used for obtaining OAuth tokens'
    )
    client_secret: Optional[str] = Field(
        None, description='Client secret key, to be used for obtaining OAuth tokens'
    )
    name: str = Field(..., description='The name of your application.')
    vapid_key: Optional[str] = Field(
        None,
        description='Used for Push Streaming API. Returned with [POST /api/v1/apps](https://docs.joinmastodon.org/methods/apps/#create-an-application). Equivalent to [PushSubscription#server_key](https://docs.joinmastodon.org/entities/pushsubscription/#server_key)',
    )
    website: Optional[str] = Field(
        None, description='The website associated with your application. Must be URL.'
    )


class Type(Enum):
    unknown = 'unknown'
    image = 'image'
    gifv = 'gifv'
    video = 'video'
    audio = 'audio'


class Attachment(BaseModel):
    blurhash: Optional[str] = Field(
        None,
        description='A hash computed by the [BlurHash algorithm](https://github.com/woltapp/blurhash), for generating colorful preview thumbnails when media has not been downloaded yet.',
    )
    description: Optional[str] = Field(
        None,
        description='Alternate text that describes what is in the media attachment, to be used for the visually impaired or when media attachments do not load.',
    )
    id: str = Field(
        ...,
        description='The ID of the attachment in the database. Cast from an integer but not guaranteed to be a number',
    )
    meta: Optional[Dict[str, Any]] = Field(
        None, description='Metadata returned by Paperclip.'
    )
    preview_url: str = Field(
        ..., description='The location of a scaled-down preview of the attachment.'
    )
    remote_url: Optional[str] = Field(
        None,
        description='The location of the full-size original attachment on the remote website. String or null if the attachment is local.',
    )
    text_url: Optional[str] = Field(
        None, description='A shorter URL for the attachment.'
    )
    type: Type = Field(..., description='The type of the attachment.')
    url: str = Field(
        ..., description='The location of the original full-size attachment.'
    )


class Type1(Enum):
    link = 'link'
    photo = 'photo'
    video = 'video'
    rich = 'rich'


class Card(BaseModel):
    author_name: Optional[str] = Field(
        None, description='The author of the original resource.'
    )
    author_url: Optional[str] = Field(
        None, description='A link to the author of the original resource.'
    )
    blurhash: Optional[str] = Field(
        None,
        description='A hash computed by the [BlurHash algorithm](https://github.com/woltapp/blurhash), for generating colorful preview thumbnails when media has not been downloaded yet.',
    )
    description: str = Field(..., description='Description of preview.')
    height: Optional[int] = Field(None, description='Height of preview, in pixels.')
    html: Optional[str] = Field(
        None, description='HTML to be used for generating the preview card.'
    )
    image: Optional[str] = Field(None, description='Preview thumbnail (URL).')
    provider_name: Optional[str] = Field(
        None, description='The provider of the original resource.'
    )
    provider_url: Optional[str] = Field(
        None, description='A link to the provider of the original resource.'
    )
    title: str = Field(..., description='Title of linked resource.')
    type: Type1 = Field(
        ..., description='The type of the preview card. String (Enumerable, oneOf).'
    )
    url: str = Field(..., description='Location of linked resource.')
    width: Optional[int] = Field(None, description='Width of preview, in pixels.')


class Emoji(BaseModel):
    category: Optional[str] = Field(
        None, description='Used for sorting custom emoji in the picker.'
    )
    shortcode: str = Field(..., description='The name of the custom emoji.')
    static_url: str = Field(
        ...,
        description='A link to a static copy of the custom emoji. The format is URL.',
    )
    url: str = Field(..., description='A link to the custom emoji. The format is URL.')
    visible_in_picker: bool = Field(
        ...,
        description='Whether this Emoji should be visible in the picker or unlisted.',
    )


class Error(BaseModel):
    error: str
    error_description: Optional[str] = None


class FeaturedTag(BaseModel):
    id: Optional[str] = Field(
        None,
        description='The internal ID of the featured tag in the database. Cast from integer but not guaranteed to be a number',
    )
    last_status_at: Optional[datetime] = Field(
        None,
        description='The timestamp of the last authored status containing this hashtag. ISO 8601 Datetime.',
    )
    name: Optional[str] = Field(
        None, description='The name of the hashtag being featured.'
    )
    statuses_count: Optional[int] = Field(
        None, description='The number of authored statuses containing this hashtag.'
    )
    url: Optional[str] = Field(
        None, description='A link to all statuses by a user that contain this hashtag.'
    )


class FieldModel(BaseModel):
    name: Optional[str] = Field(
        None, description="The key of a given field's key-value pair."
    )
    value: Optional[str] = Field(
        None, description='The value associated with the `name` key.'
    )
    verified_at: Optional[datetime] = Field(
        None,
        description='Timestamp of when the server verified a URL value for a rel="me‚Äù link. If `value` is a verified URL. Otherwise, null',
    )


class ContextEnum(Enum):
    home = 'home'
    notifications = 'notifications'
    public = 'public'
    thread = 'thread'


class Filter(BaseModel):
    context: Optional[List[ContextEnum]] = Field(
        None, description='The contexts in which the filter should be applied.'
    )
    expires_at: Optional[str] = Field(
        None,
        description='When the filter should no longer be applied. ISO 8601 Datetime, or null if the filter does not expire',
    )
    id: Optional[str] = Field(
        None,
        description='The ID of the filter in the database. Cast from an integer, but not guaranteed to be a number.',
    )
    irreversible: Optional[bool] = Field(
        None,
        description='Should matching entities in home and notifications be dropped by the server?',
    )
    phrase: Optional[str] = Field(None, description='The text to be filtered.')
    whole_word: Optional[bool] = Field(
        None, description='Should the filter consider word boundaries?'
    )


class History(BaseModel):
    accounts: str = Field(
        ...,
        description='the total of accounts using the tag within that day. Cast from an integer.',
    )
    day: str = Field(..., description='UNIX timestamp on midnight of the given day.')
    uses: str = Field(
        ...,
        description='the counted usage of the tag within that day. Cast from an integer.',
    )


class IdentityProof(BaseModel):
    profile_url: Optional[str] = Field(
        None, description="The account owner's profile URL on the identity provider."
    )
    proof_url: Optional[str] = Field(
        None,
        description='A link to a statement of identity proof, hosted by the identity provider.',
    )
    provider: Optional[str] = Field(
        None, description='The name of the identity provider.'
    )
    provider_username: Optional[str] = Field(
        None,
        description="The account owner's username on the identity provider's service.",
    )
    updated_at: Optional[str] = Field(
        None, description='When the identity proof was last updated. ISO 8601 Datetime.'
    )


class RepliesPolicy(Enum):
    followed = 'followed'
    list = 'list'
    none = 'none'


class ListModel(BaseModel):
    id: str = Field(
        ...,
        description='The internal database ID of the list. Cast from an integer, but not guaranteed to be a number.',
    )
    replies_policy: RepliesPolicy = Field(
        ..., description='The user-defined title of the list.'
    )
    title: str = Field(..., description='The user-defined title of the list.')


class Marker(BaseModel):
    home: Optional[Dict[str, Any]] = Field(
        None, description="Information about the user's position in the home timeline."
    )
    last_read_id: Optional[str] = Field(
        None,
        description='The ID of the most recently viewed entity. Cast from integer but not guaranteed to be a number',
    )
    notifications: Optional[Dict[str, Any]] = Field(
        None,
        description="Information about the user's position in their notifications.",
    )
    updated_at: Optional[datetime] = Field(
        None, description='The timestamp of when the marker was set. ISO 8601 Datetime.'
    )
    version: Optional[int] = Field(
        None, description='Used for locking to prevent write conflicts.'
    )


class Mention(BaseModel):
    acct: str = Field(
        ...,
        description='The webfinger acct URI of the mentioned user. Equivalent to `username` for local users, or `username@domain` for remote users.',
    )
    id: str = Field(
        ...,
        description='The account id of the mentioned user. Cast from an integer, but not guaranteed to be a number',
    )
    url: str = Field(..., description="The location of the mentioned user's profile.")
    username: str = Field(..., description='The username of the mentioned user.')


class Type2(Enum):
    follow = 'follow'
    follow_request = 'follow_request'
    mention = 'mention'
    reblog = 'reblog'
    favourite = 'favourite'
    poll = 'poll'
    status = 'status'


class Poll(BaseModel):
    emojis: Optional[List[Emoji]] = Field(
        None, description='Custom emoji to be used for rendering poll options.'
    )
    expired: Optional[bool] = Field(None, description='Is the poll currently expired?')
    expires_at: Optional[datetime] = Field(
        None,
        description='When the poll ends. ISO 8601 Datetime, or null if the poll does not end.',
    )
    id: Optional[str] = Field(
        None,
        description='The ID of the poll in the database. Cast from an integer, but not guaranteed to be a number.',
    )
    multiple: Optional[bool] = Field(
        None, description='Does the poll allow multiple-choice answers?'
    )
    options: Optional[List] = Field(None, description='Possible answers for the poll.')
    own_votes: Optional[List[int]] = Field(
        None,
        description='When called with a user token, which options has the authorized user chosen? Contains an array of index values for `options`. Array of Number, or null if no current user',
    )
    voted: Optional[bool] = Field(
        None,
        description='When called with a user token, has the authorized user voted? Boolean, or null if no current user',
    )
    voters_count: Optional[int] = Field(
        None,
        description='How many unique accounts have voted on a multiple-choice poll. Number, or null if `multiple` is false.',
    )
    votes_count: Optional[int] = Field(
        None, description='How many votes have been received.'
    )


class PostingDefaultVisibility(Enum):
    public = 'public'
    unlisted = 'unlisted'
    private = 'private'
    direct = 'direct'


class ReadingExpandMedia(Enum):
    default = 'default'
    show_all = 'show_all'
    hide_all = 'hide_all'


class Preferences(BaseModel):
    posting_default_language: Optional[str] = Field(
        None,
        alias='posting:default:language',
        description='Default language for new posts. Equivalent to [Source#language](https://docs.joinmastodon.org/entities/source/#language). ISO 639-1 language two-letter code, or null',
    )
    posting_default_sensitive: Optional[bool] = Field(
        None,
        alias='posting:default:sensitive',
        description='Default sensitivity flag for new posts. Equivalent to [Source#sensitive](https://docs.joinmastodon.org/entities/source/#sensitive).',
    )
    posting_default_visibility: Optional[PostingDefaultVisibility] = Field(
        None,
        alias='posting:default:visibility',
        description='Default visibility for new posts. Equivalent to [Source#privacy](https://docs.joinmastodon.org/entities/source/#privacy).',
    )
    reading_expand_media: Optional[ReadingExpandMedia] = Field(
        None,
        alias='reading:expand:media',
        description='Whether media attachments should be automatically displayed or blurred/hidden.',
    )
    reading_expand_spoilers: Optional[bool] = Field(
        None,
        alias='reading:expand:spoilers',
        description='Whether CWs should be expanded by default.',
    )


class PushSubscription(BaseModel):
    alerts: Dict[str, Any] = Field(
        ..., description='Which alerts should be delivered to the `endpoint`.'
    )
    endpoint: str = Field(..., description='Where push alerts will be sent to.')
    id: str = Field(
        ...,
        description='The ID of the push subscription in the database. Cast from an integer, but not guaranteed to be a number.',
    )
    server_key: str = Field(..., description="The streaming server's VAPID key.")


class Relationship(BaseModel):
    blocked_by: bool = Field(..., description='Is this user blocking you?')
    blocking: bool = Field(..., description='Are you blocking this user?')
    domain_blocking: bool = Field(
        ..., description="Are you blocking this user's domain?"
    )
    endorsed: bool = Field(
        ..., description='Are you featuring this user on your profile?'
    )
    followed_by: bool = Field(..., description='Are you followed by this user?')
    following: bool = Field(..., description='Are you following this user?')
    id: str = Field(
        ...,
        description='The account id. Cast from an integer, but not guaranteed to be a number.',
    )
    muting: bool = Field(..., description='Are you muting this user?')
    muting_notifications: bool = Field(
        ..., description='Are you muting notifications from this user?'
    )
    note: str = Field(..., description="This user's profile bio")
    notifying: bool = Field(
        ..., description='Have you enabled notifications for this user?'
    )
    requested: bool = Field(
        ..., description='Do you have a pending follow request for this user?'
    )
    showing_reblogs: bool = Field(
        ..., description="Are you receiving this user's boosts in your home timeline?"
    )


class Category(Enum):
    other = 'other'
    spam = 'spam'
    violation = 'violation'


class Privacy(Enum):
    public = 'public'
    unlisted = 'unlisted'
    private = 'private'
    direct = 'direct'


class Source(BaseModel):
    fields: Optional[List[FieldModel]] = Field(
        None, description='Metadata about the account.'
    )
    follow_requests_count: Optional[int] = Field(
        None, description='The number of pending follow requests'
    )
    language: Optional[str] = Field(
        None,
        description='The default posting language for new statuses, ISO 639-1 language two-letter code.',
    )
    note: Optional[str] = Field(None, description='Profile bio')
    privacy: Optional[Privacy] = Field(
        None, description='The default post privacy to be used for new statuses.'
    )
    sensitive: Optional[bool] = Field(
        None, description='Whether new statuses should be marked sensitive by default.'
    )


class Visibility(Enum):
    public = 'public'
    unlisted = 'unlisted'
    private = 'private'
    direct = 'direct'


class StatusParams(BaseModel):
    application_id: Optional[str] = Field(None, description='application_id')
    in_reply_to_id: Optional[str] = Field(None, description='in_reply_to_id')
    media_ids: Optional[List[str]] = Field(None, description='media_ids')
    scheduled_at: Optional[datetime] = Field(None, description='scheduled_at')
    sensitive: Optional[bool] = Field(None, description='sensitive')
    spoiler_text: Optional[str] = Field(None, description='spoiler_text')
    text: Optional[str] = Field(None, description='text')
    visibility: Optional[str] = Field(None, description='visibility')


class Tag(BaseModel):
    history: Optional[List[History]] = Field(
        None, description='Usage statistics for given days.'
    )
    name: str = Field(..., description='The value of the hashtag after the `#` sign.')
    url: str = Field(..., description='A link to the hashtag on the instance.')


class Token(BaseModel):
    access_token: Optional[str] = Field(
        None, description='An OAuth token to be used for authorization.'
    )
    created_at: Optional[int] = Field(
        None, description='When the token was generated. UNIX Timestamp.'
    )
    scope: Optional[str] = Field(
        None, description='The OAuth scopes granted by this token, space-separated.'
    )
    token_type: Optional[str] = Field(
        None, description='The OAuth token type. Mastodon uses `Bearer` tokens.'
    )


class ApiV1AccountsPostRequest(BaseModel):
    agreement: bool = Field(
        ...,
        description='Whether the user agrees to the local rules, terms, and policies. These should be presented to the user in order to allow them to consent before setting this parameter to TRUE.',
    )
    email: str = Field(..., description='The email address to be used for login')
    locale: str = Field(
        ..., description='The language of the confirmation email that will be sent'
    )
    password: SecretStr = Field(..., description='The password to be used for login')
    reason: Optional[str] = Field(
        None,
        description='Text that will be reviewed by moderators if registrations require manual approval.',
    )
    username: str = Field(..., description='The desired username for the account')


class ApiV1AccountsRelationshipsGetResponse(RootModel[List[Relationship]]):
    root: List[Relationship]


class Id(RootModel[List[str]]):
    root: List[str]


class Source1(BaseModel):
    language: Optional[str] = Field(
        None, description='Default language to use for authored statuses. (ISO 6391)'
    )
    privacy: Optional[str] = Field(
        None, description='Default post privacy for authored statuses.'
    )
    sensitive: Optional[bool] = Field(
        None, description='Whether to mark authored statuses as sensitive by default.'
    )


class ApiV1AccountsUpdateCredentialsPatchRequest(BaseModel):
    avatar: Optional[str] = Field(
        None, description='Avatar image encoded using multipart/form-data'
    )
    bot: Optional[bool] = Field(None, description='Whether the account has a bot flag.')
    discoverable: Optional[str] = Field(
        None,
        description='Whether the account should be shown in the profile directory.',
    )
    display_name: Optional[str] = Field(
        None, description='The display name to use for the profile.'
    )
    fields_attributes: Optional[Dict[str, Any]] = Field(
        None,
        description='Profile metadata `name` and `value`. (By default, max 4 fields and 255 characters per property/value)',
    )
    header: Optional[str] = Field(
        None, description='Header image encoded using multipart/form-data'
    )
    locked: Optional[bool] = Field(
        None, description='Whether manual approval of follow requests is required.'
    )
    note: Optional[str] = Field(None, description='The account bio.')
    source: Optional[Source1] = None


class ApiV1AccountsIdFeaturedTagsGetResponse(RootModel[List[FeaturedTag]]):
    root: List[FeaturedTag]


class ApiV1AccountsIdFollowPostRequest(BaseModel):
    notify: Optional[bool] = Field(
        False,
        description='Receive notifications when this account posts a status? Defaults to false.',
    )
    reblogs: Optional[bool] = Field(
        True,
        description="Receive this account's reblogs in home timeline? Defaults to true.",
    )


class ApiV1AccountsIdIdentityProofsGetResponse(RootModel[List[IdentityProof]]):
    root: List[IdentityProof]


class ApiV1AccountsIdListsGetResponse(RootModel[List[ListModel]]):
    root: List[ListModel]


class ApiV1AccountsIdMutePostRequest(BaseModel):
    duration: Optional[int] = Field(
        0,
        description='How long the mute should last, in seconds. Defaults to 0 (indefinite).',
    )
    notifications: Optional[bool] = Field(
        True,
        description='Mute notifications in addition to statuses? Defaults to true.',
    )


class ApiV1AccountsIdNotePostRequest(BaseModel):
    comment: Optional[str] = Field(
        None,
        description='The comment to be set on that user. Provide an empty string or leave out this parameter to clear the currently set note.',
    )


class Type3(Enum):
    none = 'none'
    disable = 'disable'
    silence = 'silence'
    suspend = 'suspend'


class ApiV1AdminAccountsIdActionPostRequest(BaseModel):
    report_id: Optional[str] = Field(
        None,
        description='ID of an associated report that caused this action to be taken',
    )
    send_email_notification: Optional[bool] = Field(
        None,
        description='Whether an email should be sent to the user with the above information.',
    )
    text: Optional[str] = Field(
        None,
        description='Additional text for clarification of why this action was taken',
    )
    type: Optional[Type3] = Field(
        None,
        description='Type of action to be taken. Enumerable oneOf: none disable silence suspend',
    )
    warning_preset_id: Optional[str] = Field(None, description='ID of a preset warning')


class ApiV1AnnouncementsGetResponse(RootModel[List[Announcement]]):
    root: List[Announcement]


class ApiV1AnnouncementsIdDismissPostResponse(BaseModel):
    pass


class ApiV1AnnouncementsIdReactionsNameDeleteResponse(BaseModel):
    pass


class ApiV1AnnouncementsIdReactionsNamePutResponse(BaseModel):
    pass


class ApiV1AppsPostRequest(BaseModel):
    client_name: str = Field(..., description='A name for your application')
    redirect_uris: str = Field(
        ...,
        description='Where the user should be redirected after authorization. To display the authorization code to the user instead of redirecting to a web page, use urn:ietf:wg:oauth:2.0:oob in this parameter.',
    )
    scopes: Optional[str] = Field(
        None,
        description='Space separated list of scopes. If none is provided, defaults to read.',
    )
    website: Optional[str] = Field(
        None, description='A URL to the homepage of your app'
    )


class ApiV1AppsPostResponse(BaseModel):
    client_id: Optional[str] = None
    client_secret: Optional[str] = None
    id: Optional[str] = None
    name: Optional[str] = None
    redirect_uri: Optional[str] = None
    vapid_key: Optional[str] = None
    website: Optional[str] = None


class ApiV1ConversationsIdDeleteResponse(BaseModel):
    pass


class ApiV1CustomEmojisGetResponse(RootModel[List[Emoji]]):
    root: List[Emoji]


class Order(Enum):
    active = 'active'
    new = 'new'


class ApiV1DomainBlocksDeleteResponse(BaseModel):
    pass


class ApiV1DomainBlocksGetResponse(RootModel[List[str]]):
    root: List[str]


class ApiV1DomainBlocksPostRequest(BaseModel):
    domain: str = Field(..., description='Domain to block.')


class ApiV1DomainBlocksPostResponse(BaseModel):
    pass


class ApiV1FeaturedTagsGetResponse(RootModel[List[FeaturedTag]]):
    root: List[FeaturedTag]


class ApiV1FeaturedTagsPostRequest(BaseModel):
    name: Optional[str] = None


class ApiV1FeaturedTagsSuggestionsGetResponse(RootModel[List[FeaturedTag]]):
    root: List[FeaturedTag]


class ApiV1FeaturedTagsIdDeleteResponse(BaseModel):
    pass


class ApiV1FiltersGetResponse(RootModel[List[Filter]]):
    root: List[Filter]


class ApiV1FiltersPostRequest(BaseModel):
    context: List[ContextEnum] = Field(
        ...,
        description='Array of enumerable strings `home`, `notifications`, `public`, `thread`. At least one context must be specified.',
    )
    expires_in: Optional[int] = Field(
        None,
        description="Number of seconds from now the filter should expire. Otherwise, null for a filter that doesn't expire.",
    )
    irreversible: Optional[bool] = Field(
        None,
        description='Should the server irreversibly drop matching entities from home and notifications?',
    )
    phrase: str = Field(..., description='Text to be filtered.')
    whole_word: Optional[bool] = Field(None, description='Consider word boundaries?')


class ApiV1FiltersIdPutRequest(BaseModel):
    context: List[ContextEnum] = Field(
        ...,
        description='Array of enumerable strings `home`, `notifications`, `public`, `thread`. At least one context must be specified.',
    )
    expires_in: Optional[int] = Field(
        None,
        description="Number of seconds from now the filter should expire. Otherwise, null for a filter that doesn't expire.",
    )
    irreversible: Optional[bool] = Field(
        None,
        description='Should the server irreversibly drop matching entities from home and notifications?',
    )
    phrase: str = Field(..., description='Text to be filtered.')
    whole_word: Optional[bool] = Field(None, description='Consider word boundaries?')


class ApiV1InstanceActivityGetResponse(RootModel[List[Activity]]):
    root: List[Activity]


class ApiV1InstancePeersGetResponse(RootModel[List[str]]):
    root: List[str]


class ApiV1ListsDeleteResponse(BaseModel):
    pass


class ApiV1ListsGetResponse(RootModel[List[ListModel]]):
    root: List[ListModel]


class ApiV1ListsPostRequest(BaseModel):
    replies_policy: Optional[RepliesPolicy] = Field(
        'list', description='Enumerable oneOf followed list none. Defaults to list.'
    )
    title: str = Field(..., description='The title of the list to be created.')


class ApiV1ListsPutRequest(BaseModel):
    replies_policy: Optional[RepliesPolicy] = Field(
        'list', description='Enumerable oneOf followed list none. Defaults to list.'
    )
    title: Optional[str] = Field(
        None, description='The title of the list to be created.'
    )


class ApiV1ListsIdAccountsDeleteResponse(BaseModel):
    pass


class AccountIds(RootModel[List[str]]):
    root: List[str]


class ApiV1ListsIdAccountsPostRequest(BaseModel):
    account_ids: List[str] = Field(
        ..., description='Array of account IDs to add to the list.'
    )


class ApiV1ListsIdAccountsPostResponse(BaseModel):
    pass


class ApiV1MarkersGetResponse(BaseModel):
    pass


class Timeline(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class ApiV1MarkersPostRequest(BaseModel):
    pass


class ApiV1MarkersPostResponse(BaseModel):
    pass


class ApiV1MediaPostRequest(BaseModel):
    description: Optional[str] = Field(
        None,
        description='A plain-text description of the media, for accessibility purposes.',
    )
    file: bytes = Field(
        ..., description='The file to be attached, using multipart form data.'
    )
    focus: Optional[str] = Field(
        None,
        description='Two floating points (x,y), comma-delimited, ranging from -1.0 to 1.0 (see ‚ÄúFocal points‚Äù below)',
    )
    thumbnail: Optional[bytes] = Field(
        None,
        description='The custom thumbnail of the media to be attached, using multipart form data.',
    )


class ApiV1MediaIdPostRequest(BaseModel):
    description: Optional[str] = Field(
        None,
        description='A plain-text description of the media, for accessibility purposes.',
    )
    file: bytes = Field(
        ..., description='The file to be attached, using multipart form data.'
    )
    focus: Optional[str] = Field(
        None,
        description='Two floating points (x,y), comma-delimited, ranging from -1.0 to 1.0 (see ‚ÄúFocal points‚Äù below)',
    )
    thumbnail: Optional[bytes] = Field(
        None,
        description='The custom thumbnail of the media to be attached, using multipart form data.',
    )


class ExcludeTypes(RootModel[List[str]]):
    root: List[str]


class ApiV1NotificationsClearPostResponse(BaseModel):
    pass


class ApiV1PollsIdPostRequest(BaseModel):
    choices: List[str]


class ApiV1PushSubscriptionDeleteResponse(BaseModel):
    pass


class ApiV1PushSubscriptionPostRequest(BaseModel):
    data: str
    subscription: str


class ApiV1PushSubscriptionPutRequest(BaseModel):
    data: str


class ApiV1ReportsPostRequest(BaseModel):
    account_id: str = Field(..., description='ID of the account to report')
    comment: Optional[str] = Field(
        None, description='Reason for the report (default max 1000 characters)'
    )
    forward: Optional[bool] = Field(
        None,
        description='If the account is remote, should the report be forwarded to the remote admin?',
    )
    status_ids: Optional[List[str]] = Field(
        None, description='Array of Statuses to attach to the report, for context'
    )


class ApiV1ScheduledStatusesIdDeleteResponse(BaseModel):
    pass


class ApiV1ScheduledStatusesIdPutRequest(BaseModel):
    scheduled_at: Optional[datetime] = Field(
        None,
        description='ISO 8601 Datetime at which the status will be published. Must be at least 5 minutes into the future.',
    )


class ApiV1StatusesPostRequestItem(BaseModel):
    in_reply_to_id: Optional[str] = Field(
        None, description='ID of the status being replied to, if status is a reply'
    )
    language: Optional[str] = Field(
        None, description='ISO 639 language code for this status.'
    )
    media_ids: Optional[List[str]] = Field(
        None,
        description='Array of Attachment ids to be attached as media. If provided, `status` becomes optional, and `poll` cannot be used.',
    )
    poll: Optional[List[Dict[str, Any]]] = None
    scheduled_at: Optional[str] = Field(
        None,
        description='ISO 8601 Datetime at which to schedule a status. Providing this paramter will cause ScheduledStatus to be returned instead of Status. Must be at least 5 minutes in the future.',
    )
    sensitive: Optional[bool] = Field(
        None, description='Mark status and attached media as sensitive?'
    )
    spoiler_text: Optional[str] = Field(
        None,
        description='Text to be shown as a warning or subject before the actual content. Statuses are generally collapsed behind this field.',
    )
    status: Optional[str] = Field(
        None,
        description='Text content of the status. If `media_ids` is provided, this becomes optional. Attaching a `poll` is optional while `status` is provided.',
    )
    visibility: Optional[Visibility] = Field(
        None,
        description='Visibility of the posted status. Enumerable oneOf public, unlisted, private, direct.',
    )


class ApiV1StatusesPostRequest(RootModel[List[ApiV1StatusesPostRequestItem]]):
    root: List[ApiV1StatusesPostRequestItem]


class ApiV1StatusesIdReblogPostRequest(BaseModel):
    visibility: Optional[str] = Field(
        None,
        description='any visibility except limited or direct (i.e. public, unlisted, private). Defaults to public. Currently unused in UI.',
    )


class ApiV1SuggestionsIdDeleteResponse(BaseModel):
    pass


class ApiV1TrendsGetResponse(RootModel[List[Tag]]):
    root: List[Tag]


class Type4(Enum):
    accounts = 'accounts'
    hashtags = 'hashtags'
    statuses = 'statuses'


class OauthRevokePostRequest(BaseModel):
    client_id: str = Field(
        ..., description='Client ID, obtained during app registration'
    )
    client_secret: str = Field(
        ..., description='Client secret, obtained during app registration'
    )
    token: str = Field(
        ..., description='The previously obtained token, to be invalidated'
    )


class OauthTokenPostRequest(BaseModel):
    client_id: str = Field(
        ..., description='Client ID, obtained during app registration'
    )
    client_secret: str = Field(
        ..., description='Client secret, obtained during app registration'
    )
    code: Optional[str] = Field(
        None, description='A user authorization code, obtained via /oauth/authorize'
    )
    grant_type: str = Field(
        ...,
        description='Set equal to authorization_code if code is provided in order to gain user-level access. Otherwise, set equal to client_credentials to obtain app-level access only.',
    )
    redirect_uri: str = Field(
        ...,
        description='Set a URI to redirect the user to. If this parameter is set to urn:ietf:wg:oauth:2.0:oob then the token will be shown instead. Must match one of the redirect URIs declared during app registration.',
    )
    scopes: Optional[str] = Field(
        None,
        description='List of requested OAuth scopes, separated by spaces. Must be a subset of scopes declared during app registration. If not provided, defaults to read.',
    )


class OauthTokenPostResponse(BaseModel):
    access_token: Optional[str] = Field(
        None, examples=['ZA-Yj3aBD8U8Cm7lKUp-lm9O9BmDgdhHzDeqsY8tlL0']
    )
    created_at: Optional[int] = Field(
        None, description='UNIX timestamp', examples=[1573979017]
    )
    scope: Optional[str] = Field(None, examples=['read write follow push'])
    token_type: Optional[str] = Field(None, examples=['Bearer'])


class Account(BaseModel):
    acct: Optional[str] = Field(
        None,
        description='The Webfinger account URI. Equal to `username` for local users, or `username@domain` for',
    )
    avatar: Optional[str] = Field(
        None,
        description='An image icon that is shown next to statuses and in the profile. The format is URL.',
    )
    avatar_static: Optional[str] = Field(
        None,
        description='A static version of the avatar. Equal to `avatar` if its value is a static image; different if `avatar` is an animated GIF. The format is URL.',
    )
    bot: Optional[bool] = Field(
        None,
        description='A presentational flag. Indicates that the account may perform automated actions, may not be monitored, or identifies as a robot.',
    )
    created_at: Optional[datetime] = Field(
        None, description='When the account was created.'
    )
    discoverable: Optional[bool] = Field(
        None,
        description='Whether the account has opted into discovery features such as the profile directory.',
    )
    display_name: Optional[str] = Field(None, description="The profile's display name.")
    emojis: Optional[List[Emoji]] = Field(
        None,
        description='Custom emoji entities to be used when rendering the profile. If none, an empty array will be returned.',
    )
    fields: Optional[List[FieldModel]] = Field(
        None,
        description='Additional metadata attached to a profile as name-value pairs.',
    )
    followers_count: Optional[int] = Field(
        None, description='The reported followers of this profile.'
    )
    following_count: Optional[int] = Field(
        None, description='The reported follows of this profile.'
    )
    header: Optional[str] = Field(
        None,
        description='An image banner that is shown above the profile and in profile cards. The format is URL.',
    )
    header_static: Optional[str] = Field(
        None,
        description='A static version of the header. Equal to `header` if its value is a static image; different if `header` is an animated GIF. The format is URL.',
    )
    id: Optional[str] = Field(None, description='The account id `header`.')
    last_status_at: Optional[datetime] = Field(
        None, description='When the most recent status was posted.'
    )
    locked: Optional[bool] = Field(
        None, description='Whether the account manually approves follow requests.'
    )
    moved: Optional[Account] = None
    mute_expires_at: Optional[datetime] = Field(
        None,
        description='When a timed mute will expire, if applicable. ISO 8601 Datetime.',
    )
    note: Optional[str] = Field(None, description="The profile's bio / description.")
    source: Optional[Source] = None
    statuses_count: Optional[int] = Field(
        None, description='How many statuses are attached to this account.'
    )
    suspended: Optional[bool] = Field(
        None, description='An extra entity returned when an account is suspended.'
    )
    url: Optional[str] = Field(
        None, description="The location of the user's profile page. (HTTPS URL)"
    )
    username: Optional[str] = Field(
        None, description='The username of the account, not including domain.'
    )


class AdminAccount(BaseModel):
    account: Optional[Account] = None
    approved: Optional[bool] = Field(
        None, description='Whether the account is currently approved.'
    )
    confirmed: Optional[bool] = Field(
        None, description='Whether the account has confirmed their email address.'
    )
    created_at: Optional[datetime] = Field(
        None, description='When the account was first discovered.'
    )
    created_by_application_id: Optional[str] = Field(
        None,
        description='The ID of the application that created this account. Cast from an integer, but not guaranteed to be a number.',
    )
    disabled: Optional[bool] = Field(
        None, description='Whether the account is currently disabled.'
    )
    email: Optional[str] = Field(
        None, description='The email address associated with the account.'
    )
    id: Optional[str] = Field(
        None,
        description='The ID of the account in the database. Cast from an integer, but not guaranteed to be a number.',
    )
    invite_request: Optional[str] = Field(None, description='Invite request text ???')
    invited_by_account_id: Optional[str] = Field(
        None,
        description='The ID of the account that invited this user. Cast from an integer, but not guaranteed to be a number.',
    )
    ip: Optional[str] = Field(
        None, description='The IP address last used to login to this account.'
    )
    locale: Optional[str] = Field(
        None,
        description='The locale of the account. ISO 639 Part 1 two-letter language code.',
    )
    role: Optional[str] = Field(
        None, description='The current role of the account. Enumerable oneOf.'
    )
    silenced: Optional[bool] = Field(
        None, description='Whether the account is currently silenced.'
    )
    suspended: Optional[bool] = Field(
        None, description='Whether the account is currently suspended.'
    )
    username: Optional[str] = Field(None, description='The username of the account.')


class Instance(BaseModel):
    approval_required: bool = Field(
        ..., description='Whether registrations require moderator approval.'
    )
    contact_account: Optional[Account] = None
    description: str = Field(
        ..., description='Admin-defined description of the Mastodon site.'
    )
    email: str = Field(
        ..., description='An email that may be contacted for any inquiries.'
    )
    invites_enabled: bool = Field(..., description='Whether invites are enabled.')
    languages: List[str] = Field(
        ...,
        description='Primary languages of the website and its staff. ISO 639 Part 1-5 language codes.',
    )
    registrations: bool = Field(..., description='Whether registrations are enabled.')
    short_description: str = Field(
        ..., description='A shorter description defined by the admin.'
    )
    stats: Dict[str, Any] = Field(
        ..., description='Statistics about how much information the instance contains.'
    )
    thumbnail: Optional[str] = Field(None, description='Banner image for the website.')
    title: str = Field(..., description='The title of the website.')
    uri: str = Field(..., description='The domain name of the instance.')
    urls: Dict[str, Any] = Field(..., description='URLs of interest for clients apps.')
    version: str = Field(
        ..., description='The version of Mastodon installed on the instance.'
    )


class Report(BaseModel):
    action_taken: Optional[bool] = None
    action_taken_at: Optional[datetime] = None
    category: Optional[Category] = None
    comment: Optional[str] = None
    created_at: Optional[datetime] = None
    forwarded: Optional[bool] = None
    id: Optional[str] = None
    rule_ids: Optional[List[int]] = None
    status_ids: Optional[List[int]] = None
    target_account: Optional[Account] = None


class ScheduledStatus(BaseModel):
    id: str = Field(
        ...,
        description='ID of the scheduled status in the database. Cast from an integer, but not guaranteed to be a number.',
    )
    media_attachments: List[Attachment] = Field(
        ..., description='Array of attachements'
    )
    params: StatusParams
    scheduled_at: datetime = Field(
        ..., description='ID of the status in the database. ISO 8601 Datetime.'
    )


class Status(BaseModel):
    account: Optional[Account] = None
    application: Optional[Application] = None
    bookmarked: Optional[bool] = Field(
        None, description='Have you bookmarked this status?'
    )
    card: Optional[Card] = None
    content: Optional[str] = Field(None, description='HTML-encoded status content.')
    created_at: Optional[datetime] = Field(
        None, description='The date when this status was created.'
    )
    emojis: Optional[List[Emoji]] = Field(
        None, description='Custom emoji to be used when rendering status content.'
    )
    favourited: Optional[bool] = Field(
        None, description='Have you favourited this status?'
    )
    favourites_count: Optional[int] = Field(
        None, description='How many favourites this status has received.'
    )
    id: Optional[str] = Field(
        None,
        description='ID of the status in the database. Cast from an integer but not guaranteed to be a number.',
    )
    in_reply_to_account_id: Optional[str] = Field(
        None, description='ID of the account being replied to.'
    )
    in_reply_to_id: Optional[str] = Field(
        None,
        description='ID of the status being replied. Cast from an integer but not guaranteed to be a number.',
    )
    language: Optional[str] = Field(
        None,
        description='Primary language of this status. ISO 639 Part 1 two-letter language code.',
    )
    media_attachments: Optional[List[Attachment]] = Field(
        None, description='Media that is attached to this status.'
    )
    mentions: Optional[List[Mention]] = Field(
        None, description='Mentions of users within the status content.'
    )
    muted: Optional[bool] = Field(
        None, description="Have you muted notifications for this status's conversation?"
    )
    pinned: Optional[bool] = Field(
        None,
        description='Have you pinned this status? Only appears if the status is pinnable.',
    )
    poll: Optional[Poll] = None
    reblog: Optional[Status] = None
    reblogged: Optional[bool] = Field(None, description='Have you boosted this status?')
    reblogs_count: Optional[int] = Field(
        None, description='How many boosts this status has received.'
    )
    replies_count: Optional[int] = Field(
        None, description='How many replies this status has received.'
    )
    sensitive: Optional[bool] = Field(
        None, description='Is this status marked as sensitive content?'
    )
    spoiler_text: Optional[str] = Field(
        None,
        description='Subject or summary line, below which status content is collapsed until expanded.',
    )
    tags: Optional[List[Tag]] = Field(
        None, description='Hashtags used within the status content.'
    )
    text: Optional[str] = Field(
        None,
        description='Plain-text source of a status. Returned instead of `content` when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.',
    )
    uri: Optional[str] = Field(
        None, description='URI of the status used for federation.'
    )
    url: Optional[str] = Field(
        None, description="A link to the status's HTML representation."
    )
    visibility: Optional[Visibility] = Field(
        None, description='Visibility of this status.'
    )


class ApiV1AccountsSearchGetResponse(RootModel[List[Account]]):
    root: List[Account]


class ApiV1AccountsIdFollowersGetResponse(RootModel[List[Account]]):
    root: List[Account]


class ApiV1AccountsIdFollowingGetResponse(RootModel[List[Account]]):
    root: List[Account]


class ApiV1AccountsIdStatusesGetResponse(RootModel[List[Status]]):
    root: List[Status]


class ApiV1AdminAccountsGetResponse(RootModel[List[AdminAccount]]):
    root: List[AdminAccount]


class ApiV1BlocksGetResponse(RootModel[List[Account]]):
    root: List[Account]


class ApiV1BookmarksGetResponse(RootModel[List[Status]]):
    root: List[Status]


class ApiV1DirectoryGetResponse(RootModel[List[Account]]):
    root: List[Account]


class ApiV1EndorsementsGetResponse(RootModel[List[Account]]):
    root: List[Account]


class ApiV1FavouritesGetResponse(RootModel[List[Status]]):
    root: List[Status]


class ApiV1FollowRequestsGetResponse(RootModel[List[Account]]):
    root: List[Account]


class ApiV1ListsIdAccountsGetResponse(RootModel[List[Account]]):
    root: List[Account]


class ApiV1MutesGetResponse(RootModel[List[Account]]):
    root: List[Account]


class ApiV1ScheduledStatusesGetResponse(RootModel[List[ScheduledStatus]]):
    root: List[ScheduledStatus]


class ApiV1StatusesPostResponse(RootModel[Union[Status, ScheduledStatus]]):
    root: Union[Status, ScheduledStatus]


class ApiV1TimelinesHomeGetResponse(RootModel[List[Status]]):
    root: List[Status]


class ApiV1TimelinesListListIdGetResponse(RootModel[List[Status]]):
    root: List[Status]


class ApiV1TimelinesPublicGetResponse(RootModel[List[Status]]):
    root: List[Status]


class ApiV1TimelinesTagHashtagGetResponse(RootModel[List[Status]]):
    root: List[Status]


class ApiV2SearchGetResponse(BaseModel):
    accounts: Optional[List[Account]] = None
    hashtags: Optional[List[Status]] = None
    statuses: Optional[List[Tag]] = None


class AdminReport(BaseModel):
    account: Optional[Account] = None
    action_taken: Optional[str] = Field(
        None, description='The action taken to resolve this report. Enumerable oneOf.'
    )
    assigned_account: Optional[Account] = None
    comment: Optional[str] = Field(
        None, description='An optional reason for reporting.'
    )
    created_at: Optional[datetime] = Field(
        None, description='The time the report was filed.'
    )
    id: Optional[str] = Field(
        None,
        description='The ID of the report in the database. Cast from an integer, but not guaranteed to be a number.',
    )
    statuses: Optional[List[Status]] = Field(
        None, description='Statuses attached to the report, for context.'
    )
    target_account: Optional[Account] = None
    updated_at: Optional[datetime] = Field(
        None, description='The time of last action on this report.'
    )


class Context(BaseModel):
    ancestors: List[Status] = Field(..., description='Parents in the thread.')
    descendants: List[Status] = Field(..., description='Children in the thread.')


class Conversation(BaseModel):
    accounts: List[Account] = Field(
        ..., description='Participants in the conversation.'
    )
    id: str = Field(
        ...,
        description='Local database ID of the conversation. Cast from an integer, but not guaranteed to be a number',
    )
    last_status: Optional[Status] = None
    unread: bool = Field(
        ..., description='Is the conversation currently marked as unread?'
    )


class Notification(BaseModel):
    account: Account
    created_at: datetime = Field(
        ..., description='The timestamp of the notification. ISO 8601 Datetime.'
    )
    id: str = Field(
        ...,
        description='The id of the notification in the database. Cast from an integer, but not guaranteed to be a number.',
    )
    status: Optional[Status] = None
    type: Type2 = Field(
        ..., description='The type of event that resulted in the notification.'
    )


class Results(BaseModel):
    accounts: List[Account] = Field(
        ..., description='Accounts which match the given query.'
    )
    hashtags: List[Tag] = Field(
        ..., description='Hashtags which match the given query.'
    )
    statuses: List[Status] = Field(
        ..., description='Statuses which match the given query.'
    )


class ApiV1AdminReportsGetResponse(RootModel[List[AdminReport]]):
    root: List[AdminReport]


class ApiV1ConversationsGetResponse(RootModel[List[Conversation]]):
    root: List[Conversation]


class ApiV1NotificationsGetResponse(RootModel[List[Notification]]):
    root: List[Notification]


Account.model_rebuild()
Status.model_rebuild()
